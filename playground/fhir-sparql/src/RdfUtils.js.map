{"version":3,"file":"RdfUtils.js","sources":["../../../../../fhircat/fhir-sparql/fhir-sparql-js/src/RdfUtils.ts"],"sourcesContent":["/* istanbul ignore file */\n\nimport {Xsd} from './Namespaces';\nimport * as SparqlJs from 'sparqljs';\nimport {BgpPattern, IriTerm, Query} from \"sparqljs\";\n// import {Triple, IriTerm, BlankTerm, VariableTerm, QuadTerm} from\nconst SparqlParser = new SparqlJs.Parser();\n\ntype S = SparqlJs.IriTerm | SparqlJs.BlankTerm | SparqlJs.VariableTerm;\ntype P = SparqlJs.IriTerm | SparqlJs.VariableTerm | SparqlJs.PropertyPath;\ntype O = S | SparqlJs.LiteralTerm;\nexport type TTerm = P | O;\ntype T = SparqlJs.Triple;\n\nexport type POS = 'subject' | 'predicate' | 'object';\n\nexport class RdfUtils {\n\n  /** find triples matching (s, p, o)\n   * could move to Bgp, but is always invokes on a List\n   */\n  static pmatch (l: P, r: P): boolean {\n    return RdfUtils.isPath(l) && RdfUtils.isPath(r)\n        ? RdfUtils.pathEquals(l, r)\n        : RdfUtils.isPath(l) || RdfUtils.isPath(r)\n        ? false\n        : l.equals(r);\n  }\n\n  static pathEquals (l: SparqlJs.PropertyPath, r: SparqlJs.PropertyPath): boolean {\n    return l.type === r.type && l.pathType === r.pathType && !l.items.find(\n        (il, iNo) => !RdfUtils.pmatch(il, r.items[iNo])\n    );\n  }\n\n  static isPath (t: TTerm): t is SparqlJs.PropertyPath {\n    return (t as SparqlJs.PropertyPath).type === \"path\";\n  }\n\n  static getMatching (triplePatterns: T[], s: S | null, p: P | null, o: O | null): SparqlJs.Triple[] {\n    return triplePatterns.filter(tp =>\n      (s === null || tp.subject.equals(s)) &&\n      (p === null || RdfUtils.pmatch(tp.predicate, p)) &&\n      (o === null || tp.object.equals(o))\n    );\n  }\n\n  /** remove triples matching (s, p, o)\n   */\n  static stealMatching (triplePatterns: T[], s: S | null, p: P | null, o: O | null): SparqlJs.Triple[] {\n    const ret = [];\n    for (let i = 0; i < triplePatterns.length; ++i) {\n      const tp = triplePatterns[i];\n      if ((s === null || tp.subject.equals(s)) &&\n          (p === null || RdfUtils.pmatch(tp.predicate, p)) &&\n          (o === null || tp.object.equals(o))) {\n        ret.push(tp);\n        triplePatterns.splice(i, 1);\n        --i;\n      }\n    }\n    return ret;\n  }\n\n  /** Stringize a predicate\n   * Used to sort arcs queried from graphs.\n   */\n  static pStr (predicate: P): string {\n    return !RdfUtils.isPath(predicate)\n      ? '<' + predicate.value + '>'\n      : '(' + predicate.items.map(item => RdfUtils.pStr(item) + (RdfUtils.isPath(item) ? item.pathType : '')).join('/') + ')'; // TODO: not correct\n  }\n}\n\nexport class Term {\n  constructor (\n      public termType: string,\n      public value: string\n  ) {\n  }\n  equals (r: Term) {\n    return this.termType === r.termType && this.value === r.value;\n  }\n  static blessSparqlJs (sparqlJsTerm: TTerm): Term | Path {\n    if (RdfUtils.isPath(sparqlJsTerm))\n      { // @ts-ignore\n        return new Path(sparqlJsTerm.pathType, sparqlJsTerm.items.map(item => Term.blessSparqlJs(item)));\n      }\n\n    switch (sparqlJsTerm.termType) {\n    case 'NamedNode': return new NamedNode(sparqlJsTerm.value);\n    case 'BlankNode': return new BlankNode(sparqlJsTerm.value);\n    case 'Literal':\n      const datatype = sparqlJsTerm.datatype ? Term.blessSparqlJs(sparqlJsTerm.datatype) as NamedNode : new NamedNode(Xsd.string.value);\n      return new Literal(sparqlJsTerm.value, sparqlJsTerm.language, datatype);\n    case 'Variable': return new Variable(sparqlJsTerm.value);\n    default: throw Error(`unknown SparqlJs term type in ${JSON.stringify(sparqlJsTerm)}`);\n    }\n  }\n}\n\nclass NamedNode extends Term { constructor (value: string) { super('NamedNode', value); } toString() { return '<' + this.value + '>'; } }\nclass BlankNode extends Term { constructor (value: string) { super('BlankNode', value); } toString() { return '_:' + this.value; } }\nclass Variable  extends Term { constructor (value: string) { super('Variable', value); } toString() { return '?' + this.value; } }\nclass Literal extends Term {\n  protected language: string;\n  protected datatype: NamedNode | null;\n  constructor (value: string, language: string, datatype: NamedNode | null) {\n    super('Literal', value);\n    this.language = language;\n    this.datatype = datatype;\n  }\n  toString () {\n    return '\"' + this.value + '\"' +\n      (this.language\n       ? '@' + this.language\n       : this.datatype && this.datatype.value !== Xsd.string.value\n       ? '^^' + this.datatype.toString()\n       : '');\n  }\n  equals (r: Term) {\n    return super.equals(r) && this.language === (r as Literal).language && this.datatype === (r as Literal).datatype;\n  }\n}\n\nexport class Path implements SparqlJs.PropertyPath {\n  public type: 'path' = 'path';\n  constructor (\n      public pathType: '|' | '/' | '^' | '+' | '*' | '!',\n      public items: Array<IriTerm | Path>,\n      // pathType, items\n  ) {\n  }\n  equals (r: Path) {\n    if (this.type !== r.type) return false;\n    if (this.pathType !== r.pathType) return false;\n    if (this.items.length !== r.items.length) return false;\n    for (let i = 0; i < this.items.length; ++i)\n      { // @ts-ignore\n        if (!this.items[i].equals(r.items[i]))\n                return false;\n      }\n    return true;\n  }\n}\n\nexport class Triple implements SparqlJs.Triple {\n  constructor (\n    public subject: S,\n    public predicate: P,\n    public object: O,\n  ) {}\n  toString () {\n    return `${this.subject} ${this.predicate} ${this.object} .`;\n  }\n  equals (r: Triple) {\n    return this.subject.equals(r.subject) &&\n      RdfUtils.pmatch(this.predicate, r.predicate) &&\n      this.object.equals(r.object);\n  }\n  static blessSparqlJs (triple: SparqlJs.Triple) {\n    return new Triple(\n      Term.blessSparqlJs(triple.subject as TTerm) as S,\n      Term.blessSparqlJs(triple.predicate as TTerm) as P,\n      Term.blessSparqlJs(triple.object as TTerm) as O,\n    );\n  }\n}\n\nexport class Bgp implements SparqlJs.BgpPattern {\n  type: 'bgp' = 'bgp';\n  constructor (\n      public triples: SparqlJs.Triple[]) {\n  }\n  toString (indent = '') {\n    return indent + '{\\n' + this.triples.map(t => indent + '  ' + t.toString() + '\\n').join('') + '}';\n  }\n  static blessSparqlJs (sparqlJsBgp: SparqlJs.BgpPattern) {\n    if (sparqlJsBgp.type !== 'bgp') throw Error(`expected to bless something with .type=bgp in ${JSON.stringify(sparqlJsBgp)}`);\n    return new Bgp(sparqlJsBgp.triples.map(t => Triple.blessSparqlJs(t)));\n  }\n}\n\nexport class SparqlQuery implements SparqlJs.SelectQuery {\n  type: 'query' = 'query';\n  // base: string | undefined;\n  prefixes: { [prefix: string]: string; } = {};\n  queryType: 'SELECT' = 'SELECT';\n  variables: [SparqlJs.Wildcard] = [new SparqlJs.Wildcard()];\n  where: SparqlJs.BgpPattern[];\n  constructor (query: SparqlJs.Query) {\n    // query.where[0].triples = query.where[0].triples.map(t => Triple.blessSparqlJs(t));\n    this.prefixes = query.prefixes;\n    //@ts-ignore\n    this.variables = query.variables;\n    this.where = this.findBgps(query).map(bgp => Bgp.blessSparqlJs(bgp as BgpPattern));\n  }\n\n  findBgps (q: SparqlJs.Query) {\n    if (q.type !== 'query' || q.queryType !== 'SELECT')\n      throw Error(q);\n    return q.where.reduce((acc, elt) => {\n      if (elt.type === 'group')\n        return acc.concat(this.findBgps(elt.patterns[0]));\n      if (elt.type === 'bgp')\n        return acc.concat([elt]);\n      console.log(`skipping ${elt.type}`);\n      return acc;\n    }, []);\n  }\n\n  getQuery () { return this; }\n  getWhere () { return this.where; };\n\n  static parse (text: string) {\n    return new SparqlQuery(SparqlParser.parse(text) as Query);\n  }\n}\n\n// export type SparqlSolution = Map<string, TTerm>;\nexport interface SparqlSolution {\n  [variable: string]: TTerm;\n}\n\nexport interface Meta {\n  base: string;\n  prefixes: {[prefix: string]: string};\n}\n"],"names":["SparqlJs.Parser","SparqlJs.Wildcard"],"mappings":";;;;;;;;;AAMA,MAAM,YAAA,GAAe,IAAIA,aAAgB,EAAA,CAAA;AAUlC,MAAM,QAAS,CAAA;AAAA;AAAA;AAAA;AAAA,EAKpB,OAAO,MAAQ,CAAA,CAAA,EAAM,CAAe,EAAA;AAClC,IAAO,OAAA,QAAA,CAAS,MAAO,CAAA,CAAC,CAAK,IAAA,QAAA,CAAS,OAAO,CAAC,CAAA,GACxC,QAAS,CAAA,UAAA,CAAW,CAAG,EAAA,CAAC,IACxB,QAAS,CAAA,MAAA,CAAO,CAAC,CAAA,IAAK,QAAS,CAAA,MAAA,CAAO,CAAC,CACvC,GAAA,KAAA,GACA,CAAE,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;AAAA,GAClB;AAAA,EAEA,OAAO,UAAY,CAAA,CAAA,EAA0B,CAAmC,EAAA;AAC9E,IAAO,OAAA,CAAA,CAAE,IAAS,KAAA,CAAA,CAAE,IAAQ,IAAA,CAAA,CAAE,aAAa,CAAE,CAAA,QAAA,IAAY,CAAC,CAAA,CAAE,KAAM,CAAA,IAAA;AAAA,MAC9D,CAAC,EAAI,EAAA,GAAA,KAAQ,CAAC,QAAA,CAAS,OAAO,EAAI,EAAA,CAAA,CAAE,KAAM,CAAA,GAAG,CAAC,CAAA;AAAA,KAClD,CAAA;AAAA,GACF;AAAA,EAEA,OAAO,OAAQ,CAAsC,EAAA;AACnD,IAAA,OAAQ,EAA4B,IAAS,KAAA,MAAA,CAAA;AAAA,GAC/C;AAAA,EAEA,OAAO,WAAA,CAAa,cAAqB,EAAA,CAAA,EAAa,GAAa,CAAgC,EAAA;AACjG,IAAA,OAAO,cAAe,CAAA,MAAA;AAAA,MAAO,CAAA,EAAA,KAAA,CAC1B,MAAM,IAAQ,IAAA,EAAA,CAAG,QAAQ,MAAO,CAAA,CAAC,OACjC,CAAM,KAAA,IAAA,IAAQ,SAAS,MAAO,CAAA,EAAA,CAAG,WAAW,CAAC,CAAA,CAAA,KAC7C,MAAM,IAAQ,IAAA,EAAA,CAAG,MAAO,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;AAAA,KACnC,CAAA;AAAA,GACF;AAAA;AAAA;AAAA,EAIA,OAAO,aAAA,CAAe,cAAqB,EAAA,CAAA,EAAa,GAAa,CAAgC,EAAA;AACnG,IAAA,MAAM,MAAM,EAAC,CAAA;AACb,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,cAAe,CAAA,MAAA,EAAQ,EAAE,CAAG,EAAA;AAC9C,MAAM,MAAA,EAAA,GAAK,eAAe,CAAC,CAAA,CAAA;AAC3B,MAAK,IAAA,CAAA,CAAA,KAAM,QAAQ,EAAG,CAAA,OAAA,CAAQ,OAAO,CAAC,CAAA,MACjC,MAAM,IAAQ,IAAA,QAAA,CAAS,OAAO,EAAG,CAAA,SAAA,EAAW,CAAC,CAC7C,CAAA,KAAA,CAAA,KAAM,QAAQ,EAAG,CAAA,MAAA,CAAO,MAAO,CAAA,CAAC,CAAI,CAAA,EAAA;AACvC,QAAA,GAAA,CAAI,KAAK,EAAE,CAAA,CAAA;AACX,QAAe,cAAA,CAAA,MAAA,CAAO,GAAG,CAAC,CAAA,CAAA;AAC1B,QAAE,EAAA,CAAA,CAAA;AAAA,OACJ;AAAA,KACF;AACA,IAAO,OAAA,GAAA,CAAA;AAAA,GACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAM,SAAsB,EAAA;AACjC,IAAA,OAAO,CAAC,QAAA,CAAS,MAAO,CAAA,SAAS,CAC7B,GAAA,GAAA,GAAM,SAAU,CAAA,KAAA,GAAQ,GACxB,GAAA,GAAA,GAAM,SAAU,CAAA,KAAA,CAAM,GAAI,CAAA,CAAA,IAAA,KAAQ,QAAS,CAAA,IAAA,CAAK,IAAI,CAAA,IAAK,QAAS,CAAA,MAAA,CAAO,IAAI,CAAA,GAAI,IAAK,CAAA,QAAA,GAAW,EAAG,CAAA,CAAA,CAAE,IAAK,CAAA,GAAG,CAAI,GAAA,GAAA,CAAA;AAAA,GACxH;AACF,CAAA;AAEO,MAAM,IAAK,CAAA;AAAA,EAChB,WAAA,CACW,UACA,KACT,EAAA;AAFS,IAAA,IAAA,CAAA,QAAA,GAAA,QAAA,CAAA;AACA,IAAA,IAAA,CAAA,KAAA,GAAA,KAAA,CAAA;AAAA,GAEX;AAAA,EACA,OAAQ,CAAS,EAAA;AACf,IAAA,OAAO,KAAK,QAAa,KAAA,CAAA,CAAE,QAAY,IAAA,IAAA,CAAK,UAAU,CAAE,CAAA,KAAA,CAAA;AAAA,GAC1D;AAAA,EACA,OAAO,cAAe,YAAkC,EAAA;AACtD,IAAI,IAAA,QAAA,CAAS,MAAO,CAAA,YAAY,CAC9B,EAAA;AACE,MAAA,OAAO,IAAI,IAAA,CAAK,YAAa,CAAA,QAAA,EAAU,YAAa,CAAA,KAAA,CAAM,GAAI,CAAA,CAAA,IAAA,KAAQ,IAAK,CAAA,aAAA,CAAc,IAAI,CAAC,CAAC,CAAA,CAAA;AAAA,KACjG;AAEF,IAAA,QAAQ,aAAa,QAAU;AAAA,MAC/B,KAAK,WAAA;AAAa,QAAO,OAAA,IAAI,SAAU,CAAA,YAAA,CAAa,KAAK,CAAA,CAAA;AAAA,MACzD,KAAK,WAAA;AAAa,QAAO,OAAA,IAAI,SAAU,CAAA,YAAA,CAAa,KAAK,CAAA,CAAA;AAAA,MACzD,KAAK,SAAA;AACH,QAAA,MAAM,QAAW,GAAA,YAAA,CAAa,QAAW,GAAA,IAAA,CAAK,aAAc,CAAA,YAAA,CAAa,QAAQ,CAAA,GAAiB,IAAI,SAAA,CAAU,GAAI,CAAA,MAAA,CAAO,KAAK,CAAA,CAAA;AAChI,QAAA,OAAO,IAAI,OAAQ,CAAA,YAAA,CAAa,KAAO,EAAA,YAAA,CAAa,UAAU,QAAQ,CAAA,CAAA;AAAA,MACxE,KAAK,UAAA;AAAY,QAAO,OAAA,IAAI,QAAS,CAAA,YAAA,CAAa,KAAK,CAAA,CAAA;AAAA,MACvD;AAAS,QAAA,MAAM,MAAM,CAAiC,8BAAA,EAAA,IAAA,CAAK,SAAU,CAAA,YAAY,CAAC,CAAE,CAAA,CAAA,CAAA;AAAA,KACpF;AAAA,GACF;AACF,CAAA;AAEA,MAAM,kBAAkB,IAAK,CAAA;AAAA,EAAE,YAAa,KAAe,EAAA;AAAE,IAAA,KAAA,CAAM,aAAa,KAAK,CAAA,CAAA;AAAA,GAAG;AAAA,EAAE,QAAW,GAAA;AAAE,IAAO,OAAA,GAAA,GAAM,KAAK,KAAQ,GAAA,GAAA,CAAA;AAAA,GAAK;AAAE,CAAA;AACxI,MAAM,kBAAkB,IAAK,CAAA;AAAA,EAAE,YAAa,KAAe,EAAA;AAAE,IAAA,KAAA,CAAM,aAAa,KAAK,CAAA,CAAA;AAAA,GAAG;AAAA,EAAE,QAAW,GAAA;AAAE,IAAA,OAAO,OAAO,IAAK,CAAA,KAAA,CAAA;AAAA,GAAO;AAAE,CAAA;AACnI,MAAM,iBAAkB,IAAK,CAAA;AAAA,EAAE,YAAa,KAAe,EAAA;AAAE,IAAA,KAAA,CAAM,YAAY,KAAK,CAAA,CAAA;AAAA,GAAG;AAAA,EAAE,QAAW,GAAA;AAAE,IAAA,OAAO,MAAM,IAAK,CAAA,KAAA,CAAA;AAAA,GAAO;AAAE,CAAA;AACjI,MAAM,gBAAgB,IAAK,CAAA;AAAA,EAGzB,WAAA,CAAa,KAAe,EAAA,QAAA,EAAkB,QAA4B,EAAA;AACxE,IAAA,KAAA,CAAM,WAAW,KAAK,CAAA,CAAA;AAHxB,IAAU,aAAA,CAAA,IAAA,EAAA,UAAA,CAAA,CAAA;AACV,IAAU,aAAA,CAAA,IAAA,EAAA,UAAA,CAAA,CAAA;AAGR,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAChB,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAAA,GAClB;AAAA,EACA,QAAY,GAAA;AACV,IAAO,OAAA,GAAA,GAAM,KAAK,KAAQ,GAAA,GAAA,IACvB,KAAK,QACH,GAAA,GAAA,GAAM,KAAK,QACX,GAAA,IAAA,CAAK,YAAY,IAAK,CAAA,QAAA,CAAS,UAAU,GAAI,CAAA,MAAA,CAAO,QACpD,IAAO,GAAA,IAAA,CAAK,QAAS,CAAA,QAAA,EACrB,GAAA,EAAA,CAAA,CAAA;AAAA,GACP;AAAA,EACA,OAAQ,CAAS,EAAA;AACf,IAAO,OAAA,KAAA,CAAM,MAAO,CAAA,CAAC,CAAK,IAAA,IAAA,CAAK,aAAc,CAAc,CAAA,QAAA,IAAY,IAAK,CAAA,QAAA,KAAc,CAAc,CAAA,QAAA,CAAA;AAAA,GAC1G;AACF,CAAA;AAEO,MAAM,IAAsC,CAAA;AAAA,EAEjD,WAAA,CACW,UACA,KAET,EAAA;AAHS,IAAA,IAAA,CAAA,QAAA,GAAA,QAAA,CAAA;AACA,IAAA,IAAA,CAAA,KAAA,GAAA,KAAA,CAAA;AAHX,IAAA,aAAA,CAAA,IAAA,EAAO,MAAe,EAAA,MAAA,CAAA,CAAA;AAAA,GAMtB;AAAA,EACA,OAAQ,CAAS,EAAA;AACf,IAAI,IAAA,IAAA,CAAK,SAAS,CAAE,CAAA,IAAA;AAAM,MAAO,OAAA,KAAA,CAAA;AACjC,IAAI,IAAA,IAAA,CAAK,aAAa,CAAE,CAAA,QAAA;AAAU,MAAO,OAAA,KAAA,CAAA;AACzC,IAAA,IAAI,IAAK,CAAA,KAAA,CAAM,MAAW,KAAA,CAAA,CAAE,KAAM,CAAA,MAAA;AAAQ,MAAO,OAAA,KAAA,CAAA;AACjD,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,KAAK,KAAM,CAAA,MAAA,EAAQ,EAAE,CACvC,EAAA;AACE,MAAI,IAAA,CAAC,KAAK,KAAM,CAAA,CAAC,EAAE,MAAO,CAAA,CAAA,CAAE,KAAM,CAAA,CAAC,CAAC,CAAA;AAC5B,QAAO,OAAA,KAAA,CAAA;AAAA,KACjB;AACF,IAAO,OAAA,IAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEO,MAAM,MAAkC,CAAA;AAAA,EAC7C,WAAA,CACS,OACA,EAAA,SAAA,EACA,MACP,EAAA;AAHO,IAAA,IAAA,CAAA,OAAA,GAAA,OAAA,CAAA;AACA,IAAA,IAAA,CAAA,SAAA,GAAA,SAAA,CAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA,CAAA;AAAA,GACN;AAAA,EACH,QAAY,GAAA;AACV,IAAO,OAAA,CAAA,EAAG,KAAK,OAAO,CAAA,CAAA,EAAI,KAAK,SAAS,CAAA,CAAA,EAAI,KAAK,MAAM,CAAA,EAAA,CAAA,CAAA;AAAA,GACzD;AAAA,EACA,OAAQ,CAAW,EAAA;AACjB,IAAA,OAAO,KAAK,OAAQ,CAAA,MAAA,CAAO,CAAE,CAAA,OAAO,KAClC,QAAS,CAAA,MAAA,CAAO,IAAK,CAAA,SAAA,EAAW,EAAE,SAAS,CAAA,IAC3C,KAAK,MAAO,CAAA,MAAA,CAAO,EAAE,MAAM,CAAA,CAAA;AAAA,GAC/B;AAAA,EACA,OAAO,cAAe,MAAyB,EAAA;AAC7C,IAAA,OAAO,IAAI,MAAA;AAAA,MACT,IAAA,CAAK,aAAc,CAAA,MAAA,CAAO,OAAgB,CAAA;AAAA,MAC1C,IAAA,CAAK,aAAc,CAAA,MAAA,CAAO,SAAkB,CAAA;AAAA,MAC5C,IAAA,CAAK,aAAc,CAAA,MAAA,CAAO,MAAe,CAAA;AAAA,KAC3C,CAAA;AAAA,GACF;AACF,CAAA;AAEO,MAAM,GAAmC,CAAA;AAAA,EAE9C,YACW,OAA4B,EAAA;AAA5B,IAAA,IAAA,CAAA,OAAA,GAAA,OAAA,CAAA;AAFX,IAAc,aAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA;AAAA,GAGd;AAAA,EACA,QAAA,CAAU,SAAS,EAAI,EAAA;AACrB,IAAA,OAAO,MAAS,GAAA,KAAA,GAAQ,IAAK,CAAA,OAAA,CAAQ,IAAI,CAAK,CAAA,KAAA,MAAA,GAAS,IAAO,GAAA,CAAA,CAAE,UAAa,GAAA,IAAI,CAAE,CAAA,IAAA,CAAK,EAAE,CAAI,GAAA,GAAA,CAAA;AAAA,GAChG;AAAA,EACA,OAAO,cAAe,WAAkC,EAAA;AACtD,IAAA,IAAI,YAAY,IAAS,KAAA,KAAA;AAAO,MAAA,MAAM,MAAM,CAAiD,8CAAA,EAAA,IAAA,CAAK,SAAU,CAAA,WAAW,CAAC,CAAE,CAAA,CAAA,CAAA;AAC1H,IAAO,OAAA,IAAI,GAAI,CAAA,WAAA,CAAY,OAAQ,CAAA,GAAA,CAAI,OAAK,MAAO,CAAA,aAAA,CAAc,CAAC,CAAC,CAAC,CAAA,CAAA;AAAA,GACtE;AACF,CAAA;AAEO,MAAM,WAA4C,CAAA;AAAA,EAOvD,YAAa,KAAuB,EAAA;AANpC,IAAgB,aAAA,CAAA,IAAA,EAAA,MAAA,EAAA,OAAA,CAAA,CAAA;AAEhB;AAAA,IAAA,aAAA,CAAA,IAAA,EAAA,UAAA,EAA0C,EAAC,CAAA,CAAA;AAC3C,IAAsB,aAAA,CAAA,IAAA,EAAA,WAAA,EAAA,QAAA,CAAA,CAAA;AACtB,IAAA,aAAA,CAAA,IAAA,EAAA,WAAA,EAAiC,CAAC,IAAIC,eAAS,EAAU,CAAA,CAAA,CAAA;AACzD,IAAA,aAAA,CAAA,IAAA,EAAA,OAAA,CAAA,CAAA;AAGE,IAAA,IAAA,CAAK,WAAW,KAAM,CAAA,QAAA,CAAA;AAEtB,IAAA,IAAA,CAAK,YAAY,KAAM,CAAA,SAAA,CAAA;AACvB,IAAK,IAAA,CAAA,KAAA,GAAQ,IAAK,CAAA,QAAA,CAAS,KAAK,CAAA,CAAE,IAAI,CAAO,GAAA,KAAA,GAAA,CAAI,aAAc,CAAA,GAAiB,CAAC,CAAA,CAAA;AAAA,GACnF;AAAA,EAEA,SAAU,CAAmB,EAAA;AAC3B,IAAA,IAAI,CAAE,CAAA,IAAA,KAAS,OAAW,IAAA,CAAA,CAAE,SAAc,KAAA,QAAA;AACxC,MAAA,MAAM,MAAM,CAAC,CAAA,CAAA;AACf,IAAA,OAAO,CAAE,CAAA,KAAA,CAAM,MAAO,CAAA,CAAC,KAAK,GAAQ,KAAA;AAClC,MAAA,IAAI,IAAI,IAAS,KAAA,OAAA;AACf,QAAO,OAAA,GAAA,CAAI,OAAO,IAAK,CAAA,QAAA,CAAS,IAAI,QAAS,CAAA,CAAC,CAAC,CAAC,CAAA,CAAA;AAClD,MAAA,IAAI,IAAI,IAAS,KAAA,KAAA;AACf,QAAA,OAAO,GAAI,CAAA,MAAA,CAAO,CAAC,GAAG,CAAC,CAAA,CAAA;AACzB,MAAA,OAAA,CAAQ,GAAI,CAAA,CAAA,SAAA,EAAY,GAAI,CAAA,IAAI,CAAE,CAAA,CAAA,CAAA;AAClC,MAAO,OAAA,GAAA,CAAA;AAAA,KACT,EAAG,EAAE,CAAA,CAAA;AAAA,GACP;AAAA,EAEA,QAAY,GAAA;AAAE,IAAO,OAAA,IAAA,CAAA;AAAA,GAAM;AAAA,EAC3B,QAAY,GAAA;AAAE,IAAA,OAAO,IAAK,CAAA,KAAA,CAAA;AAAA,GAAO;AAAA,EAEjC,OAAO,MAAO,IAAc,EAAA;AAC1B,IAAA,OAAO,IAAI,WAAA,CAAY,YAAa,CAAA,KAAA,CAAM,IAAI,CAAU,CAAA,CAAA;AAAA,GAC1D;AACF;;;;"}