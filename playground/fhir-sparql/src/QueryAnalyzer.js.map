{"version":3,"file":"QueryAnalyzer.js","sources":["../../../../../fhircat/fhir-sparql/fhir-sparql-js/src/QueryAnalyzer.ts"],"sourcesContent":["import {ShExVisitor} from './ShExVisitor';\nimport {Ns} from './Namespaces';\nimport {RdfUtils, SparqlQuery, Triple, TTerm} from './RdfUtils';\nimport {ArcTree, PosArcTree} from './ArcTree'\nimport * as ShExJ from 'shexj';\n\nexport class PredicateToShapeDecls extends ShExVisitor {\n  predicateToShapeDecls: Map<string, ShExJ.ShapeDecl[]>;\n  resourceTypeToShapeDeclIds: Map<string, string[]>;\n  curDecl: ShExJ.ShapeDecl | null;\n\n  constructor (...ctor_args: any[]) {\n    super(...ctor_args);\n    this.predicateToShapeDecls = new Map(); // not used\n    this.resourceTypeToShapeDeclIds = new Map();\n    this.curDecl = null;\n  }\n\n  visitSchema(schema: ShExJ.Schema, ...args: any[]) {\n    if (!schema || !(typeof schema === 'object') || schema.type !== 'Schema')\n      throw Error(`visitSchema argument must be a schema, got ${JSON.stringify(schema)}`);\n    return super.visitSchema(schema, ...args);\n  }\n\n  visitShapeDecl(decl: ShExJ.ShapeDecl, ...args: any[]) {\n\n    // capture hierarchy implied by shape labels text\n    let resourceType = (decl.id.split(/\\./))[0];\n    let ids = this.resourceTypeToShapeDeclIds.get(resourceType);\n    if (!ids) {\n      ids = [];\n      this.resourceTypeToShapeDeclIds.set(resourceType, ids);\n    }\n    ids.push(decl.id);\n\n    // index nested tripleExprs\n    this.curDecl = decl;\n    const ret = super.visitShapeDecl(decl, ...args);\n    this.curDecl = null;\n    return ret;\n  }\n\n  visitTripleConstraint(expr: ShExJ.TripleConstraint, ...args: any[]) {\n    if (this.curDecl === null)\n      throw new Error(`visiting ${JSON.stringify(expr)} while not in a ShapeDecl`);\n    if (!expr.predicate.startsWith(Ns.rdf) && [Ns.fhir + 'v', Ns.fhir + 'nodeRole'].indexOf(expr.predicate) === -1) {\n      if (!this.predicateToShapeDecls.has(expr.predicate))\n        this.predicateToShapeDecls.set(expr.predicate, []);\n      this.predicateToShapeDecls.get(expr.predicate)!.push(this.curDecl);\n    }\n    return null;\n  }\n\n  visitNodeConstraint(nc: ShExJ.NodeConstraint, ...args: any[]) { // don't bother visiting NodeConstraints\n    return null;\n  }\n}\n\nexport class QueryAnalyzer {\n  predicateToShapeDecls: Map<string, ShExJ.ShapeDecl[]>;\n  resourceTypeToShapeDeclIds: Map<string, string[]>;\n  constructor (\n      public shex: ShExJ.Schema\n  ) {\n    if (shex) { // allow for shex-less invocation for rule compilation\n      const visitor = new PredicateToShapeDecls();\n      visitor.visitSchema(shex);\n      this.predicateToShapeDecls = visitor.predicateToShapeDecls; // not used\n      this.resourceTypeToShapeDeclIds = visitor.resourceTypeToShapeDeclIds;\n    } else {\n      this.predicateToShapeDecls = new Map();\n      this.resourceTypeToShapeDeclIds = new Map();\n    }\n  }\n\n  getArcTrees (query: SparqlQuery) {\n    const triples = query.getWhere()[0].triples as Triple[];\n\n    const todo: Triple[] = triples.slice().sort((l, r) => RdfUtils.pStr(l.predicate).localeCompare(RdfUtils.pStr(r.predicate)));\n    /*\n      console.log(todo.map(t => t.subject.value + ' ' + FhirSparql.pStr(t.predicate) + ' ' + t.object.value).join(\"\\n\"));\n       1 ?obs fhir:code ?codeList\n       3 ?coding fhir:code ?codeCode\n      10 ?subject fhir:id ?patIdElt\n       8 ?subjectRef fhir:reference ?subject\n       7 ?obs fhir:subject ?subjectRef\n       5 ?coding fhir:system ?codingSystem\n       4 ?codeCode fhir:v 1234567\n       6 ?codingSystem fhir:v \"http://snomed.info/id\"\n      11 ?patIdElt fhir:v ?patId\n       2 ?codeList rdf:first* /rdf:rest ?coding\n       0 ?obs a fhir:Observation\n       9 ?subject a fhir:Patient\n     */\n\n    // All known ArcTrees\n    const arcTrees: ArcTree[] = [];\n    // Variables connecting ArcTrees\n    const connectingVariables: Map<string, PosArcTree[]> = new Map();\n\n    // All variables in starting operation (like a BGP, but with path expressions included)\n    const usedVars = new Map();\n\n    const referents: Set<string> = new Set();\n\n    while (todo.length > 0) {\n      // Pick a starting triple from remaining triples\n      const start = todo[0];\n\n      // Index from variable name to ArcTree\n      const treeVars: Map<string, PosArcTree[]> = new Map();\n\n      // Terminal ancesters of start.subject\n      const roots: TTerm[] = [];\n\n      // Working list of triples in start's tree.\n      let tz = [start];\n      do {\n        // tz for the next pass\n        const newTz: Triple[] = [];\n\n        tz.forEach(t => {\n          // get the node's incoming arcs (actually, just one in every scenario I've imagined).\n          // @ts-ignore\n          const arcsIn = RdfUtils.getMatching(todo, null, null, t.subject);\n\n          // it either has incoming arcs or it's a root.\n          if (arcsIn.length === 0) {\n            // @ts-ignore\n            roots.push(t.subject);\n          } else {\n            // barf if there's a cycle\n            arcsIn.forEach(p => {\n              if (p.subject.equals(start.subject))\n                throw Error(`can't handle cycle involving ${p}`);\n            });\n\n            // find parents of these arcs on next iteration\n            Array.prototype.push.apply(newTz, arcsIn);\n          }\n        });\n        tz = newTz;\n      } while (tz.length > 0);\n      console.assert(roots.length > 0, 'should have a root (if there were any triples at all)');\n\n      // build tree and index variables\n      Array.prototype.push.apply(arcTrees, roots.map(root =>\n        ArcTree.constructArcTree(todo, null, root, treeVars, referents)\n      ));\n\n      // Sort treeVars for this tree\n      for (const [k, treeNodes] of treeVars) {\n        if (connectingVariables.has(k)) {\n          // Already known ConnectingVariable\n          Array.prototype.push.apply(treeNodes);\n        } else if (usedVars.has(k)) {\n          // Already used in previous ArcTree so it's now a ConnectingVariabel\n          connectingVariables.set(k, usedVars.get(k).concat(treeNodes));\n          usedVars.delete(k);\n        } else {\n          // First tree in which this variable appears\n          usedVars.set(k, treeNodes);\n        }\n      }\n    }\n\n    return {arcTrees, connectingVariables, referents};\n  }\n}\n"],"names":[],"mappings":"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"}