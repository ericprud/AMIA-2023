{"version":3,"file":"FhirSparql.js","sources":["../../../../../fhircat/fhir-sparql/fhir-sparql-js/src/FhirSparql.ts"],"sourcesContent":["import {QueryAnalyzer} from './QueryAnalyzer';\nimport {Ns, Rdf} from './Namespaces';\nimport {RdfUtils, SparqlQuery, TTerm, SparqlSolution, Meta} from './RdfUtils';\nimport {ArcTree, PosArcTree} from './ArcTree';\nimport * as ShExJ from 'shexj';\nimport * as SparqlJs from \"sparqljs\";\nimport {ArcTreeFitsInShapeExpr} from './ArcTreeFitsInShapeExpr';\n\nexport class ConnectingVariables {\n  static toString (cvs: Map<string, PosArcTree[]>) {\n    const lines = [];\n    for (const [variable, trees] of cvs) {\n      lines.push(variable);\n      trees.forEach((tree, i) =>\n        lines.push(` ${i}: ${tree.pos} of { ${tree.arcTree.toString()} }`)\n      );\n    }\n    return lines.join('\\n');\n  }\n}\n\nclass Rule {\n  arcTree: ArcTree;\n  constructor (\n      public fhirQuery: string,\n      sparql: string,\n      public arg = (values: string[]) => values[0]\n  ) {\n    const query = SparqlQuery.parse('PREFIX fhir: <http://hl7.org/fhir/> PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT ?v1 { ' + sparql + ' }');\n    this.arcTree = new QueryAnalyzer(null as unknown as ShExJ.Schema).getArcTrees(query).arcTrees[0].out[0];\n    this.arg = arg;\n  }\n\n  toString () {\n    return \"TODO\"\n  }\n}\n\nconst Rule_Id = new Rule('id', '[] fhir:id [ fhir:v ?v1 ]')\n\nconst Rule_Subject = new Rule('subject', '[] fhir:subject [ fhir:reference ?v1 ]')\n\nexport const Rule_CodeWithSystem = new Rule( // exported for tests/FhirSparq-test\n  'code',\n  `\n[] fhir:code [\n  fhir:coding [\n    (rdf:first/rdf:rest)*/rdf:first [\n      fhir:code [ fhir:v ?v1 ] ;\n      fhir:system [ fhir:v ?v2 ]\n    ]\n  ]\n]`,\n  (values) => values[1] + '|' + values[0]\n);\n\nconst Rule_CodeWithOutSystem = new Rule(\n  'code',\n  `\n[] fhir:code [\n    fhir:coding [\n       (rdf:first/rdf:rest)*/rdf:first [\n        fhir:code [\n          fhir:v ?v1\n        ]\n      ]\n    ]\n  ]`\n);\n\n/* e.g.\n  name looks for: family, given, prefix, suffix, text\n  fhir:name ( [] [\n     fhir:use [ fhir:v \"official\" ] ;\n     fhir:family [ fhir:v \"Chalmers\" ] ;\n     fhir:given ( [ fhir:v \"Peter\" ] [ fhir:v \"James\" ] )\n  ] [] )\n*/\n\n/* probably `name` parameters are superceded by `family` and `given`\nconst Rule_NameFamily = new Rule(\n  'name',\n  `\n[] fhir:name [\n  fhir:family [\n    fhir:v ?v1\n    ]}\n  ]}`\n)\n}\n\nconst Rule_NameGiven = new Rule(\n  'name',\n  `\n[] fhir:name [\n  fhir:family [\n    fhir:v ?v1\n  ]\n]`;\n}\n*/\n\nconst Rule_Family = new Rule(\n  'family',\n  `\n[] fhir:name [\n  fhir:family [\n    fhir:v ?v1\n  ]\n]`\n);\n\nconst Rule_Given = new Rule(\n  'given',\n  `\n[] fhir:name [\n  fhir:given [\n    fhir:v ?v1\n  ]\n]`\n);\n\nclass QueryParam {\n  constructor (\n      public name: string,\n      public value: string\n  ) {\n  }\n}\n\nexport class FhirPathExecution {\n  constructor (\n      public type: string,\n      public version: string | null,\n      public paths: QueryParam[],\n      ) {}\n}\n\n/** list of 1 or more candidate rules.\n * last one standing wins\n */\nclass RuleChoice {\n  constructor (\n      public choices: Rule[]\n  ) {}\n\n  accept (arcTrees: ArcTree[], sparqlSolution: SparqlSolution) {\n    for (let choiceNo = 0; choiceNo < this.choices.length; ++choiceNo) {\n      const choice = this.choices[choiceNo];\n      const values = this.parallelWalk(arcTrees, choice.arcTree, choiceNo, sparqlSolution);\n      if (values !== null)\n        return new QueryParam (choice.fhirQuery, choice.arg(values.map(v => (v as SparqlJs.IriTerm).value)));\n    }\n    return null;\n  }\n\n  parallelWalk (testArcTrees: ArcTree[], myArcTree: ArcTree, choiceNo: number, sparqlSolution: SparqlSolution): (TTerm | null)[] | null {\n    const needed = myArcTree.out.slice(); // copy because needed gets spliced if members are matched\n    const matched: (TTerm | null)[]  = testArcTrees.map(testArcTree => {\n      if (RdfUtils.pmatch(testArcTree.tp.predicate, myArcTree.tp.predicate)) {\n        if (myArcTree.out.length === 0) {\n          // match!\n          let matchedTerm: TTerm = testArcTree.tp.object;\n          if (['Variable', 'BlankNode'].indexOf(matchedTerm.termType) !== -1) {\n            if (!sparqlSolution[matchedTerm.value])\n              return null;\n            matchedTerm = sparqlSolution[matchedTerm.value]\n          }\n          // istanbul ignore next line -- otherwise flags next line as uncovered though tests show it isn't.\n          if (RdfUtils.isPath(matchedTerm)) {\n            throw Error(`unexpected RDF Property Path in ${JSON.stringify(matchedTerm)}`)\n          } else {\n            switch (matchedTerm.termType) {\n                // case 'BlankNode':\n                //   return null; // this indicates we don't have a value so we can't bind it\n              case 'NamedNode':\n              case 'Literal':\n                return [matchedTerm]; // guessing lanuage and datatype are unimportant in FHIRPath\n                // case 'Variable':\n                //   const boundValue = sparqlSolution[matchedTerm.value];\n                //   return boundValue ? [boundValue] : null;\n                // istanbul ignore next line\n              default: // istanbul ignore next line\n                throw Error(`unexpected RDF term type in ${JSON.stringify(matchedTerm)}`)\n            }\n          }\n        } else {\n          // this.choices[choiceNo] // advance me\n          const nestedRet = [];\n          for (let myOutIdx = 0; myOutIdx < needed.length; ++myOutIdx) {\n            const ret = this.parallelWalk(testArcTree.out, needed[myOutIdx], choiceNo, sparqlSolution);\n            if (ret !== null) {\n              needed.splice(myOutIdx, 1); // we matched a needed arcTree\n              --myOutIdx;\n              nestedRet.push(ret);\n            }\n          }\n          return nestedRet.length === 0 ? null : nestedRet.flat();\n        }\n      } else {\n        // not this testArcTree; try again\n        return null;\n      }\n    }).flat();\n    const vals = matched!.filter(x => !!x);\n    if (vals.length && needed.length === 0) {\n      // console.log(`matched ${JSON.stringify(vals)}`);\n      return vals;\n    } else {\n      return null;\n    }\n  }\n}\n\nconst RuleChoice_Id = new RuleChoice([Rule_Id]); // gets removed if id supplied by root URL\n\nconst ResourceToPaths = {\n  \"EveryResource\": [RuleChoice_Id],\n  \"Observation\": [new RuleChoice([Rule_Subject]), new RuleChoice([Rule_CodeWithSystem, Rule_CodeWithOutSystem])],\n  \"Patient\": [new RuleChoice([Rule_Given]), new RuleChoice([Rule_Family])], // new RuleChoice([Rule_NameFamily]), new RuleChoice([Rule_NameGiven])\n  \"Procedure\": [new RuleChoice([Rule_Subject]), new RuleChoice([Rule_CodeWithSystem, Rule_CodeWithOutSystem])],\n  \"Questionnaire\": [],\n}\n\nconst AllResources = [\n  'Observation',\n  'Patient',\n  'Procedure',\n  'Questionnaire'\n]; // That's all of 'em; trust me.\n\nconst ResourceTypeRegexp = new RegExp(\n            '^https?://.*?/([A-Z][a-z]+)/([^/|]+)(?:\\\\|(.*))?$'\n);\n\nexport class FhirSparql extends QueryAnalyzer {\n  tester: ArcTreeFitsInShapeExpr;\n  constructor (shex: ShExJ.Schema) {\n    super(shex);\n    this.tester = new ArcTreeFitsInShapeExpr(shex);\n  }\n\n  opBgpToFhirPathExecutions (arcTree: ArcTree, referents: Set<string>, sparqlSolution: SparqlSolution, meta: Meta = {base: '', prefixes: {}}) {\n    let resourceType = null;\n    let resourceId = null;\n    let resourceUrl = null;\n    let resourceVersion: string | null = null;\n\n    const prefilledRules: QueryParam[] = [];\n    const allResourceRules = ResourceToPaths.EveryResource.slice();\n    let candidateTypes = null; // initialized soon\n\n    // There must be at least one Triple in the arcTree or it wouldn't exist.\n    const rootTriple = arcTree.out[0].tp;\n\n    switch (rootTriple.subject.termType) {\n    case 'NamedNode':\n      resourceUrl = rootTriple.subject.value;\n      break;\n    case 'Variable':\n      // If the root node was the object of a FHIR reference\n      if (referents.has(rootTriple.subject.value) && sparqlSolution[rootTriple.subject.value])\n        resourceUrl = (sparqlSolution[rootTriple.subject.value] as SparqlJs.IriTerm).value;\n    }\n\n    if (resourceUrl !== null) {\n      // parse the URL according to FHIR Protocol\n      const match = resourceUrl.match(ResourceTypeRegexp);\n      if (!match)\n        throw Error(`subject node ${resourceUrl} didn\\'t match FHIR protocol`);\n      resourceType = match[1];\n      resourceId = match[2];\n      resourceVersion = match[3] || null;\n\n      // Sanity-check parsed resourcetype\n      // istanbul ignore next line\n      if (AllResources.indexOf(resourceType) === -1) // istanbul ignore next line\n        throw Error(`did not recognize FHIR Resource in ${resourceUrl}`)\n      candidateTypes = [resourceType];\n\n      // Add id QueryParam\n      prefilledRules.push(new QueryParam(Rule_Id.fhirQuery, resourceId));\n\n      // Remove Rule_Id from candidateRules\n      const idRuleIdx = allResourceRules.indexOf(RuleChoice_Id);\n      // istanbul ignore next line\n      if (idRuleIdx === -1) // istanbul ignore next line\n        throw Error(`should have an id rule from ResourceToPaths.EveryResource: ${ResourceToPaths.EveryResource}`);\n      allResourceRules.splice(idRuleIdx, 1);\n\n    } else if (RdfUtils.pmatch(rootTriple.predicate, Rdf.type as SparqlJs.IriTerm)) {\n      // If there's a type arc, it's the first child.\n      resourceType = rootTriple.object.value.substring(Ns.fhir.length);\n      candidateTypes = [resourceType];\n\n    } else {\n      // could be any resource.\n      candidateTypes = AllResources;\n    }\n\n    // Build list of candidate rules.\n    return candidateTypes.filter(type => {\n      // const tpz = arcTree.toSparqlTriplePatterns(sparqlSolution, meta);\n      const candidateShapeLabels = this.resourceTypeToShapeDeclIds.get(type);\n      return candidateShapeLabels!.find(label => { // stop on first match in canidate shape even if it fits in multiple places\n        // istanbul ignore next line\n        if (arcTree.tp !== null) // istanbul ignore next line\n          throw Error(`Expected root of ArcTree to be null: ${arcTree.toString()}`)\n        return !arcTree.out.find(child => !this.tester.visitShapeRef(label, child));\n      });\n    }).map(type => {\n      const myResourceRules = allResourceRules.slice();\n      Array.prototype.push.apply(myResourceRules, ResourceToPaths[type as keyof typeof ResourceToPaths]);\n      const acceptedPaths = myResourceRules\n          .map(ruleChoice => ruleChoice.accept(arcTree.out, sparqlSolution)) // top tree has no tp\n          .filter(queryParam => queryParam !== null) as QueryParam[];\n      const paths = prefilledRules.concat(acceptedPaths);\n\n      return new FhirPathExecution(type, resourceVersion, paths);\n    })\n  }\n}\n\n// module.exports = {FhirSparql, ConnectingVariables, ArcTree, FhirPathExecution, Rule_CodeWithSystem};\n"],"names":[],"mappings":"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"}