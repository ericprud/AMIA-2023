{"version":3,"file":"ArcTreeFitsInShapeExpr.js","sources":["../../../../../fhircat/fhir-sparql/fhir-sparql-js/src/ArcTreeFitsInShapeExpr.ts"],"sourcesContent":["import {ShExVisitor} from './ShExVisitor';\nimport {Term} from './RdfUtils';\nimport {ArcTree} from './ArcTree';\nimport * as ShExJ from 'shexj';\nimport {shapeExprTest} from \"@shexjs/term/shexv\";\nimport * as SparqlJs from \"sparqljs\";\nimport type {Term as RdfJsTerm} from 'rdf-js';\n\nimport {ShExValidator, ShapeExprValidationContext} from \"@shexjs/validator\";\n//@ts-ignore\nconst NoMatch = Term.blessSparqlJs({termType: 'NamedNode', value: 'should://never/match'});\n\n/**\n * test whether an ArcTree is completely covered by a schema.\n *\n * Note that only *some* children of a ShapeAnd or EachOf must account for the ArcTree.\n * strategy: look for any children or extends, even Nots, than can match arcTree.\n *\n * Weakness: currently accepts if any {con,dis}junct accepts. Should accept only if all conjuncts that mention X accept X.\n */\nexport class ArcTreeFitsInShapeExpr extends ShExVisitor {\n  shex: ShExJ.Schema;\n  tested: Map<ArcTree, Map<ShExJ.ShapeDecl, shapeExprTest> >;\n  constructor (shex: ShExJ.Schema, ...ctor_args: any[]) {\n    if (!shex.shapes)\n      throw Error('construct ArcTreeFitsInShapeExpr with a ShEx schema with shapes');\n    super(...ctor_args);\n    this.shex = shex;\n    this.tested = new Map(); // straightforward results cache\n  }\n\n  visitShapeDecl(decl: ShExJ.ShapeDecl, arcTree: ArcTree, ...args: any[]) {\n    let testedShapeExprs = this.tested.get(arcTree);\n    if (!testedShapeExprs) {\n      testedShapeExprs = new Map();\n      this.tested.set(arcTree, testedShapeExprs);\n    }\n\n    let shapeExprResults = testedShapeExprs.get(decl);\n    if (!shapeExprResults) {\n      shapeExprResults = this.visitShapeExpr(decl.shapeExpr, arcTree, ...args);\n      testedShapeExprs.set(decl, shapeExprResults!); // not sure how this could be undefined\n    }\n\n    return shapeExprResults;\n  }\n\n  visitShapeRef(reference: ShExJ.shapeDeclRef, arcTree: ArcTree, ...args: any[]) {\n    const shapeDecl = this.shex.shapes!.find(decl => decl.id === reference);\n    if (!shapeDecl)\n      throw Error(`Shape ${reference} not found in ${this.shex.shapes!.map(decl => decl.id).join(', ')}`);\n    return this.visitShapeDecl(shapeDecl, arcTree, ...args);\n  }\n\n  visitShapeAnd (expr: ShExJ.ShapeAnd, arcTree: ArcTree, ...args: any[]) {\n    return !!expr.shapeExprs.find(nested => this.visitShapeExpr(nested, arcTree, ...args));\n  }\n\n  visitShapeOr (expr: ShExJ.ShapeOr, arcTree: ArcTree, ...args: any[]) {\n    return !!expr.shapeExprs.find(nested => this.visitShapeExpr(nested, arcTree, ...args));\n  }\n\n  visitShapeNot (expr: ShExJ.ShapeNot, arcTree: ArcTree, ...args: any[]) {\n    return this.visitShapeExpr(expr.shapeExpr, arcTree, ...args);\n  }\n\n  visitShape (shape: ShExJ.Shape, arcTree: ArcTree, ...args: any[]) {\n    if (shape.extends)\n      for (const ext of shape.extends)\n        if (this.visitShapeExpr(ext, arcTree, ...args))\n          return true;\n    return shape.expression ? this.visitTripleExpr(shape.expression, arcTree, shape.closed, ...args) : true;\n  }\n\n  visitNodeConstraint (nc: ShExJ.NodeConstraint, arcTree: ArcTree, closed: Boolean, ...args: any[]) { // don't bother visiting NodeConstraints\n    let focus = arcTree.tp.subject;\n    if ([\"BlankNode\", \"Variable\"].indexOf(focus.termType) !== -1)\n      return true; // in SPARQL context, vars and bnodes match anything\n    // Otherwise, perform regular NodeConstraint validation on arcTree.subject.\n    // horrible js hack for efficiency requires intimate knowledge of internals:\n    const res = ShExValidator.prototype.validateNodeConstraint.call({evaluateShapeExprSemActs: (ncRet: shapeExprTest, nc: ShExJ.NodeConstraint, focus: RdfJsTerm, label: ShExJ.Shape) => []}, focus, nc, new ShapeExprValidationContext(null, \"asdf\"));\n    // less horrible hack uses published API:\n    // const validator = new ShExValidator(this.shex, undefined, undefined);\n    // const res = validator.validateNodeConstraint(focus, nc, {label: \"asdf\"});\n    return !(res as any).errors;\n  }\n\n  visitEachOf (expr: ShExJ.EachOf, arcTree: ArcTree, closed: Boolean, ...args: any[]) {\n    return !!expr.expressions.find(nested => this.visitTripleExpr(nested, arcTree, closed, ...args));\n  }\n\n  visitOneOf (expr: ShExJ.OneOf, arcTree: ArcTree, closed: Boolean, ...args: any[]) {\n    return !!expr.expressions.find(nested => this.visitTripleExpr(nested, arcTree, closed, ...args));\n  }\n\n  visitTripleConstraint(expr: ShExJ.TripleConstraint, arcTree:ArcTree, _closed: Boolean, ...args: any[]) {\n    // TODO: !closed\n    // TODO: shape paths\n    // hack: special case (rdf:first/rdf:rest)*/rdf:first\n    let p = arcTree.tp.predicate as SparqlJs.PropertyPath; // might be SparqlJs.IriTerm\n    if (p.type === \"path\" && p.pathType === \"/\") {\n      const t = p.items.find(item => (item as SparqlJs.PropertyPath).pathType !== \"*\"); // skip past '*'s\n      if (t)\n        p = t as SparqlJs.PropertyPath;\n      else\n        throw Error(`need support for ${JSON.stringify(p)}`);\n    }\n    if (expr.predicate !== (p as unknown as SparqlJs.IriTerm).value) // TODO: expr.min === 0\n      return false;\n    if (!expr.valueExpr)\n      return arcTree.out.length === 0;\n    if (arcTree.out.length === 0) {\n      // valueExpr could have NodeConstraints or Shapes with min card of 0.\n      // Make an unmatchable Triple. This is kind of a hack to avoid creating a union type.\n      return this.visitShapeExpr(expr.valueExpr, new ArcTree({\n        //@ts-ignore\n        subject: arcTree.tp.object, predicate: NoMatch, object: NoMatch\n      }, []), ...args);\n    }\n    return !arcTree.out.find(childArcTree => {\n      return !this.visitShapeExpr(expr.valueExpr!, childArcTree, ...args);\n    });\n  }\n}\n"],"names":["ShExValidator","nc","focus","ShapeExprValidationContext"],"mappings":"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"}