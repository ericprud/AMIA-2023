{"version":3,"file":"shex-xsd.js","sources":["../../../../../../../../fhircat/fhir-sparql/fhir-sparql-js/node_modules/@shexjs/validator/lib/shex-xsd.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.testFacets = exports.testKnownTypes = exports.getNumericDatatype = void 0;\nconst XSD = \"http://www.w3.org/2001/XMLSchema#\";\nconst integerDatatypes = [\n    XSD + \"integer\",\n    XSD + \"nonPositiveInteger\",\n    XSD + \"negativeInteger\",\n    XSD + \"long\",\n    XSD + \"int\",\n    XSD + \"short\",\n    XSD + \"byte\",\n    XSD + \"nonNegativeInteger\",\n    XSD + \"unsignedLong\",\n    XSD + \"unsignedInt\",\n    XSD + \"unsignedShort\",\n    XSD + \"unsignedByte\",\n    XSD + \"positiveInteger\"\n];\nconst decimalDatatypes = [\n    XSD + \"decimal\",\n].concat(integerDatatypes);\nconst numericDatatypes = [\n    XSD + \"float\",\n    XSD + \"double\"\n].concat(decimalDatatypes);\nconst numericParsers = {};\nnumericParsers[XSD + \"integer\"] = function (label, parseError) {\n    if (!(label.match(/^[+-]?[0-9]+$/))) {\n        parseError(\"illegal integer value '\" + label + \"'\");\n    }\n    return parseInt(label);\n};\nnumericParsers[XSD + \"decimal\"] = function (label, parseError) {\n    if (!(label.match(/^[+-]?(?:[0-9]*\\.[0-9]+|[0-9]+)$/))) { // XSD has no pattern for decimal?\n        parseError(\"illegal decimal value '\" + label + \"'\");\n    }\n    return parseFloat(label);\n};\nconst DECIMAL_REGEX = /^[+\\-]?(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+)(?:[eE][+\\-]?[0-9]+)?$/;\nnumericParsers[XSD + \"float\"] = function (label, parseError) {\n    if (label === \"NaN\")\n        return NaN;\n    if (label === \"INF\")\n        return Infinity;\n    if (label === \"-INF\")\n        return -Infinity;\n    if (!(label.match(DECIMAL_REGEX))) { // XSD has no pattern for float?\n        parseError(\"illegal float value '\" + label + \"'\");\n    }\n    return parseFloat(label);\n};\nnumericParsers[XSD + \"double\"] = function (label, parseError) {\n    if (label === \"NaN\")\n        return NaN;\n    if (label === \"INF\")\n        return Infinity;\n    if (label === \"-INF\")\n        return -Infinity;\n    if (!(label.match(DECIMAL_REGEX))) {\n        parseError(\"illegal double value '\" + label + \"'\");\n    }\n    return Number(label);\n};\nfunction testRange(value, datatype, parseError) {\n    const ranges = {\n        //    integer            -1 0 1 +1 | \"\" -1.0 +1.0 1e0 NaN INF\n        //    decimal            -1 0 1 +1 -1.0 +1.0 | \"\" 1e0 NaN INF\n        //    float              -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n        //    double             -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n        //    nonPositiveInteger -1 0 +0 -0 | 1 +1 1a a1\n        //    negativeInteger    -1 | 0 +0 -0 1\n        //    long               -1 0 1 +1 |\n        //    int                -1 0 1 +1 |\n        //    short              -32768 0 32767 | -32769 32768\n        //    byte               -128 0 127 | \"\" -129 128\n        //    nonNegativeInteger 0 -0 +0 1 +1 | -1\n        //    unsignedLong       0 1 | -1\n        //    unsignedInt        0 1 | -1\n        //    unsignedShort      0 65535 | -1 65536\n        //    unsignedByte       0 255 | -1 256\n        //    positiveInteger    1 | -1 0\n        //    string             \"\" \"a\" \"0\"\n        //    boolean            true false 0 1 | \"\" TRUE FALSE tRuE fAlSe -1 2 10 01\n        //    dateTime           \"2012-01-02T12:34:56.78Z\" | \"\" \"2012-01-02T\" \"2012-01-02\"\n        integer: { min: -Infinity, max: Infinity },\n        decimal: { min: -Infinity, max: Infinity },\n        float: { min: -Infinity, max: Infinity },\n        double: { min: -Infinity, max: Infinity },\n        nonPositiveInteger: { min: -Infinity, max: 0 },\n        negativeInteger: { min: -Infinity, max: -1 },\n        long: { min: -9223372036854775808, max: 9223372036854775807 },\n        int: { min: -2147483648, max: 2147483647 },\n        short: { min: -32768, max: 32767 },\n        byte: { min: -128, max: 127 },\n        nonNegativeInteger: { min: 0, max: Infinity },\n        unsignedLong: { min: 0, max: 18446744073709551615 },\n        unsignedInt: { min: 0, max: 4294967295 },\n        unsignedShort: { min: 0, max: 65535 },\n        unsignedByte: { min: 0, max: 255 },\n        positiveInteger: { min: 1, max: Infinity }\n    };\n    const parms = ranges[datatype.substr(XSD.length)];\n    if (!parms)\n        throw Error(\"unexpected datatype: \" + datatype);\n    if (value < parms.min) {\n        parseError(`\"${value}\"^^<${datatype}> is less than the min: ${parms.min}`);\n    }\n    else if (value > parms.max) {\n        parseError(`\"${value}\"^^<${datatype}> is greater than the min: ${parms.max}`);\n    }\n}\n;\n/*\nfunction intSubType (spec, label, parseError) {\n  const ret = numericParsers[XSD + \"integer\"](label, parseError);\n  if (\"min\" in spec && ret < spec.min)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be < \" + spec.min);\n  if (\"max\" in spec && ret > spec.max)\n    parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be > \" + spec.max);\n  return ret;\n}\n[{type: \"nonPositiveInteger\", max: 0},\n {type: \"negativeInteger\", max: -1},\n {type: \"long\", min: -9223372036854775808, max: 9223372036854775807}, // beyond IEEE double\n {type: \"int\", min: -2147483648, max: 2147483647},\n {type: \"short\", min: -32768, max: 32767},\n {type: \"byte\", min: -128, max: 127},\n {type: \"nonNegativeInteger\", min: 0},\n {type: \"unsignedLong\", min: 0, max: 18446744073709551615},\n {type: \"unsignedInt\", min: 0, max: 4294967295},\n {type: \"unsignedShort\", min: 0, max: 65535},\n {type: \"unsignedByte\", min: 0, max: 255},\n {type: \"positiveInteger\", min: 1}].forEach(function (i) {\n   numericParsers[XSD + i.type ] = function (label, parseError) {\n     return intSubType(i, label, parseError);\n   };\n });\n*/\nconst stringTests = {\n    length: function (v, l) { return v.length === l; },\n    minlength: function (v, l) { return v.length >= l; },\n    maxlength: function (v, l) { return v.length <= l; }\n};\nconst numericValueTests = {\n    mininclusive: function (n, m) { return n >= m; },\n    minexclusive: function (n, m) { return n > m; },\n    maxinclusive: function (n, m) { return n <= m; },\n    maxexclusive: function (n, m) { return n < m; }\n};\nconst decimalLexicalTests = {\n    totaldigits: function (v, d) {\n        const m = v.match(/[0-9]/g);\n        return !!m && m.length <= d;\n    },\n    fractiondigits: function (v, d) {\n        const m = v.match(/^[+-]?[0-9]*\\.?([0-9]*)$/);\n        return !!m && m[1].length <= d;\n    }\n};\nfunction getNumericDatatype(value) {\n    return value.termType !== \"Literal\"\n        ? null\n        : integerDatatypes.indexOf(value.datatype.value) !== -1\n            ? XSD + \"integer\"\n            : numericDatatypes.indexOf(value.datatype.value) !== -1\n                ? value.datatype.value\n                : null;\n}\nexports.getNumericDatatype = getNumericDatatype;\nfunction testKnownTypes(value, validationError, ldify, datatype, numeric, label) {\n    if (value.termType !== \"Literal\") {\n        validationError(`mismatched datatype: ${JSON.stringify(ldify(value))} is not a literal with datatype ${datatype}`);\n    }\n    else if (value.datatype.value !== datatype) {\n        validationError(`mismatched datatype: ${value.datatype.value} !== ${datatype}`);\n    }\n    else if (numeric) {\n        testRange(numericParsers[numeric](label, validationError), datatype, validationError);\n    }\n    else if (datatype === XSD + \"boolean\") {\n        if (label !== \"true\" && label !== \"false\" && label !== \"1\" && label !== \"0\")\n            validationError(`illegal boolean value: ${label}`);\n    }\n    else if (datatype === XSD + \"dateTime\") {\n        if (!label.match(/^[+-]?\\d{4}-[01]\\d-[0-3]\\dT[0-5]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+)?([+-][0-2]\\d:[0-5]\\d|Z)?$/))\n            validationError(`illegal dateTime value: ${label}`);\n    }\n}\nexports.testKnownTypes = testKnownTypes;\nfunction testFacets(valueExpr, label, validationError, numeric) {\n    if (valueExpr.pattern !== undefined) {\n        const regexp = valueExpr.flags !== undefined ?\n            new RegExp(valueExpr.pattern, valueExpr.flags) :\n            new RegExp(valueExpr.pattern);\n        if (!(label.match(regexp)))\n            validationError(`value ${label} did not match pattern ${valueExpr.pattern}`);\n    }\n    for (const [facet, testFunc] of Object.entries(stringTests)) {\n        // @ts-ignore - TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'NodeConstraint'\n        const facetParm = valueExpr[facet];\n        if (facet in valueExpr && !testFunc(label, facetParm)) {\n            validationError(`facet violation: expected ${facet} of ${facetParm} but got ${label}`);\n        }\n    }\n    for (const [facet, testFunc] of Object.entries(numericValueTests)) {\n        if (facet in valueExpr) {\n            if (numeric) {\n                // @ts-ignore - TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'NodeConstraint'\n                const facetParm = valueExpr[facet];\n                if (!testFunc(numericParsers[numeric](label, validationError), facetParm)) {\n                    validationError(`facet violation: expected ${facet} of ${facetParm} but got ${label}`);\n                }\n            }\n            else {\n                validationError(`facet violation: numeric facet ${facet} can't apply to ${label}`);\n            }\n        }\n    }\n    for (const [facet, testFunc] of Object.entries(decimalLexicalTests)) {\n        if (facet in valueExpr) {\n            if (numeric === XSD + \"integer\" || numeric === XSD + \"decimal\") {\n                const normalizedDataValue = String(numericParsers[numeric](label, validationError));\n                // @ts-ignore - TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'NodeConstraint'\n                const facetParm = valueExpr[facet];\n                if (!testFunc(normalizedDataValue, facetParm)) {\n                    validationError(`facet violation: expected ${facet} of ${facetParm} but got ${label}`);\n                }\n            }\n            else {\n                validationError(`facet violation: numeric facet ${facet} can't apply to ${label}`);\n            }\n        }\n    }\n}\nexports.testFacets = testFacets;\n//# sourceMappingURL=shex-xsd.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0]}