{"version":3,"file":"eval-threaded-nerr.js","sources":["../../../../../../../../fhircat/fhir-sparql/fhir-sparql-js/node_modules/@shexjs/eval-threaded-nerr/lib/eval-threaded-nerr.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RegexpModule = void 0;\nconst term_1 = require(\"@shexjs/term\");\nconst UNBOUNDED = -1;\nclass RegexpThread {\n    constructor(avail = new Map(), errors = [], matched = [], expression) {\n        this.avail = avail;\n        this.errors = errors;\n        this.matched = matched;\n        this.expression = expression;\n    }\n    makeResultsThread(expr, tests, errors, matched, minmax) {\n        return new RegexpThread(new Map(this.avail), // copy parent thread's avail vector,\n        errors, matched.concat({\n            triples: tests.map(p => p.triple)\n        }), Object.assign({ type: \"TripleConstraintSolutions\", predicate: expr.predicate }, expr.valueExpr !== undefined ? { valueExpr: expr.valueExpr } : {}, expr.id !== undefined ? { productionLabel: expr.id } : {}, minmax, { solutions: tests.map(p => p.tested) }));\n    }\n    makeMissingPropertyThread(expr, matched) {\n        return new RegexpThread(this.avail, this.errors.concat([\n            Object.assign({ type: \"MissingProperty\", property: expr.predicate }, expr.valueExpr ? { valueExpr: expr.valueExpr } : {})\n        ]), matched);\n    }\n}\nexports.RegexpModule = {\n    name: \"eval-threaded-nerr\",\n    description: \"emulation of regular expression engine with error permutations\",\n    /* compile - compile regular expression and index triple constraints\n     */\n    compile: (_schema, shape, index) => {\n        return new EvalThreadedNErrRegexEngine(shape, index); // not called if there's no expression\n    }\n};\nclass EvalThreadedNErrRegexEngine {\n    constructor(shape, index) {\n        this.shape = shape;\n        this.index = index;\n        this.outerExpression = shape.expression;\n    }\n    match(node, constraintToTripleMapping, semActHandler, _trace) {\n        const allTriples = constraintToTripleMapping.reduce((allTriples, _tripleConstraint, tripleResult) => {\n            tripleResult.forEach(res => allTriples.add(res.triple));\n            return allTriples;\n        }, new Set());\n        const startingThread = new RegexpThread();\n        const ret = this.matchTripleExpression(this.outerExpression, startingThread, constraintToTripleMapping, semActHandler);\n        // console.log(JSON.stringify(ret));\n        // note: don't return if ret.length === 1 because it might fail the unmatchedTriples test.\n        const longerChosen = ret.reduce((ret, elt) => {\n            if (elt.errors.length > 0)\n                return ret; // early return\n            const unmatchedTriples = new Set(allTriples);\n            // Removed triples matched in this thread.\n            elt.matched.forEach(m => {\n                m.triples.forEach(t => {\n                    unmatchedTriples.delete(t);\n                });\n            });\n            // Remaining triples are unaccounted for.\n            unmatchedTriples.forEach(t => {\n                elt.errors.push({\n                    type: \"ExcessTripleViolation\",\n                    triple: t,\n                });\n            });\n            return ret !== null ? ret : // keep first solution\n                // Accept thread with no unmatched triples.\n                unmatchedTriples.size > 0 ? null : elt;\n        }, null);\n        if (longerChosen !== null) {\n            let fromValidationPoint = longerChosen.expression;\n            if (this.shape.semActs !== undefined)\n                fromValidationPoint.semActs = this.shape.semActs;\n            return fromValidationPoint;\n        }\n        else {\n            return ret.length > 1 ? {\n                type: \"PossibleErrors\",\n                errors: ret.reduce((all, e) => {\n                    return all.concat([e.errors]);\n                }, [])\n            } : {\n                type: \"Failure\",\n                node: node,\n                errors: ret[0].errors\n            };\n        }\n    }\n    matchTripleExpression(expr, thread, constraintToTripleMapping, semActHandler) {\n        if (typeof expr === \"string\") { // Inclusion\n            const included = this.index.tripleExprs[expr];\n            return this.matchTripleExpression(included, thread, constraintToTripleMapping, semActHandler);\n        }\n        let min = expr.min !== undefined ? expr.min : 1;\n        let max = expr.max !== undefined ? expr.max === UNBOUNDED ? Infinity : expr.max : 1;\n        switch (expr.type) {\n            case \"OneOf\":\n                return this.matchOneOf(expr, min, max, thread, constraintToTripleMapping, semActHandler);\n            case \"EachOf\":\n                return this.matchEachOf(expr, min, max, thread, constraintToTripleMapping, semActHandler);\n            case \"TripleConstraint\":\n                return this.matchTripleConstraint(expr, min, max, thread, constraintToTripleMapping, semActHandler);\n            default:\n                throw Error(\"how'd we get here?\");\n        }\n    }\n    matchOneOf(oneOf, min, max, thread, constraintToTripleMapping, semActHandler) {\n        return EvalThreadedNErrRegexEngine.matchRepeat(oneOf, min, max, thread, \"OneOfSolutions\", (th) => {\n            // const accept = null;\n            const matched = [];\n            const failed = [];\n            for (const nested of oneOf.expressions) {\n                const thcopy = new RegexpThread(new Map(th.avail), th.errors, th.matched //.slice() ever needed??\n                );\n                const sub = this.matchTripleExpression(nested, thcopy, constraintToTripleMapping, semActHandler);\n                if (sub[0].errors.length === 0) { // all subs pass or all fail\n                    Array.prototype.push.apply(matched, sub);\n                    sub.forEach(newThread => {\n                        const expressions = thcopy.solution !== undefined ? thcopy.solution.expressions : [];\n                        if (newThread.expression !== undefined) // undefined for no matches on min card:0\n                            expressions.push(newThread.expression);\n                        delete newThread.expression;\n                        newThread.solution = {\n                            type: \"OneOfSolution\",\n                            expressions: expressions\n                        };\n                    });\n                }\n                else\n                    Array.prototype.push.apply(failed, sub);\n            }\n            return matched.length > 0 ? matched : failed;\n        }, semActHandler);\n    }\n    matchEachOf(expr, min, max, thread, constraintToTripleMapping, semActHandler) {\n        return EvalThreadedNErrRegexEngine.homogenize(EvalThreadedNErrRegexEngine.matchRepeat(expr, min, max, thread, \"EachOfSolutions\", (th) => {\n            // Iterate through nested expressions, exprThreads starts as [th].\n            return expr.expressions.reduce((exprThreads, nested) => {\n                // Iterate through current thread list composing nextThreads.\n                // Consider e.g.\n                // <S1> { <p1> . | <p2> .; <p3> . } / { <x> <p2> 2; <p3> 3 } (should pass)\n                // <S1> { <p1> .; <p2> . }          / { <s1> <p1> 1 }        (should fail)\n                return EvalThreadedNErrRegexEngine.homogenize(exprThreads.reduce((nextThreads, exprThread) => {\n                    const sub = this.matchTripleExpression(nested, exprThread, constraintToTripleMapping, semActHandler);\n                    // Move newThread.expression into a hierarchical solution structure.\n                    sub.forEach(newThread => {\n                        if (newThread.errors.length === 0) {\n                            const expressions = exprThread.solution !== undefined ? exprThread.solution.expressions.slice() : [];\n                            if (newThread.expression !== undefined) // undefined for no matches on min card:0\n                                expressions.push(newThread.expression);\n                            delete newThread.expression;\n                            newThread.solution = {\n                                type: \"EachOfSolution\",\n                                expressions: expressions // exprThread.expression + newThread.expression\n                            };\n                        }\n                    });\n                    return nextThreads.concat(sub);\n                }, []));\n            }, [th]);\n        }, semActHandler));\n    }\n    // Early return in case of insufficient matching triples\n    matchTripleConstraint(constraint, min, max, thread, constraintToTripleMapping, semActHandler) {\n        if (thread.avail.get(constraint) === undefined)\n            thread.avail.set(constraint, constraintToTripleMapping.get(constraint).map(pair => pair.triple));\n        const taken = thread.avail.get(constraint).splice(0, min);\n        if (!(taken.length >= min)) // Early return\n            return [thread.makeMissingPropertyThread(constraint, thread.matched)];\n        const ret = [];\n        const minmax = {};\n        if (constraint.min !== undefined && constraint.min !== 1 || constraint.max !== undefined && constraint.max !== 1) {\n            minmax.min = constraint.min;\n            minmax.max = constraint.max;\n        }\n        if (constraint.semActs !== undefined)\n            minmax.semActs = constraint.semActs;\n        if (constraint.annotations !== undefined)\n            minmax.annotations = constraint.annotations;\n        do {\n            const passFail = taken.reduce((acc, triple) => {\n                const tested = {\n                    type: \"TestedTriple\",\n                    subject: (0, term_1.rdfJsTerm2Ld)(triple.subject),\n                    predicate: (0, term_1.rdfJsTerm2Ld)(triple.predicate),\n                    object: (0, term_1.rdfJsTerm2Ld)(triple.object)\n                };\n                const hit = constraintToTripleMapping.get(constraint).find(x => x.triple === triple);\n                if (hit.res !== undefined)\n                    tested.referenced = hit.res;\n                const semActErrors = thread.errors.concat(constraint.semActs !== undefined\n                    ? semActHandler.dispatchAll(constraint.semActs, { triples: [triple], tripleExpr: constraint }, tested)\n                    : []);\n                if (semActErrors.length > 0)\n                    acc.fail.push({ triple, tested, semActErrors });\n                else\n                    acc.pass.push({ triple, tested, semActErrors });\n                return acc;\n            }, { pass: [], fail: [] });\n            // return an empty solution if min card was 0\n            if (passFail.fail.length === 0) {\n                // If we didn't take anything, fall back to old errors.\n                // Could do something fancy here with a semAct registration for negative matches.\n                const totalErrors = taken.length === 0 ? thread.errors.slice() : [];\n                const myThread = thread.makeResultsThread(constraint, passFail.pass, totalErrors, thread.matched, minmax);\n                ret.push(myThread);\n            }\n            else {\n                passFail.fail.forEach(f => ret.push(thread.makeResultsThread(constraint, [f], f.semActErrors, thread.matched, minmax)));\n            }\n        } while ((() => {\n            if (thread.avail.get(constraint).length > 0 && taken.length < max) {\n                // build another thread.\n                taken.push(thread.avail.get(constraint).shift());\n                return true;\n            }\n            else {\n                // no more threads\n                return false;\n            }\n        })());\n        return ret;\n    }\n    /*\n       * returns: list of all passing or all failing threads (no heterogeneous lists)\n       */\n    static matchRepeat(groupTE, min, max, thread, type, evalGroup, semActHandler) {\n        let repeated = 0, errOut = false;\n        let newThreads = [thread];\n        const minmax = {};\n        if (groupTE.min !== undefined && groupTE.min !== 1 || groupTE.max !== undefined && groupTE.max !== 1) {\n            minmax.min = groupTE.min;\n            minmax.max = groupTE.max;\n        }\n        if (groupTE.semActs !== undefined)\n            minmax.semActs = groupTE.semActs;\n        if (groupTE.annotations !== undefined)\n            minmax.annotations = groupTE.annotations;\n        for (; repeated < max && !errOut; ++repeated) {\n            let inner = [];\n            for (let t = 0; t < newThreads.length; ++t) {\n                const newt = newThreads[t];\n                const sub = evalGroup(newt);\n                if (sub.length > 0 && sub[0].errors.length === 0) { // all subs pass or all fail\n                    sub.forEach(newThread => {\n                        const solutions = newt.expression !== undefined ? newt.expression.solutions.slice() : [];\n                        if (newThread.solution !== undefined)\n                            solutions.push(newThread.solution);\n                        delete newThread.solution;\n                        newThread.expression = Object.assign({\n                            type: type,\n                            solutions: solutions\n                        }, minmax);\n                    });\n                }\n                if (sub.length === 0 /* min:0 */ || sub[0].errors.length > 0)\n                    return repeated < min ? sub : newThreads;\n                else\n                    inner = inner.concat(sub);\n                // newThreads.expressions.push(sub);\n            }\n            newThreads = inner;\n        }\n        if (newThreads.length > 0 && newThreads[0].errors.length === 0 && groupTE.semActs !== undefined) {\n            const passes = [];\n            const failures = [];\n            for (const newThread of newThreads) {\n                const ctx = {\n                    triples: newThread.matched.flatMap(m => m.triples),\n                    tripleExpr: groupTE,\n                };\n                const semActErrors = semActHandler.dispatchAll(groupTE.semActs, ctx, newThread);\n                if (semActErrors.length === 0) {\n                    passes.push(newThread);\n                }\n                else {\n                    Array.prototype.push.apply(newThread.errors, semActErrors);\n                    failures.push(newThread);\n                }\n            }\n            newThreads = passes.length > 0 ? passes : failures;\n        }\n        return newThreads;\n    }\n    static homogenize(list) {\n        return list.reduce((acc, elt) => {\n            if (elt.errors.length === 0) {\n                if (acc.errors) {\n                    return { errors: false, l: [elt] };\n                }\n                else {\n                    return { errors: false, l: acc.l.concat(elt) };\n                }\n            }\n            else {\n                if (acc.errors) {\n                    return { errors: true, l: acc.l.concat(elt) };\n                }\n                else {\n                    return acc;\n                }\n            }\n        }, { errors: true, l: [] }).l;\n    }\n}\n//# sourceMappingURL=eval-threaded-nerr.js.map"],"names":["require$$0"],"mappings":"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","x_google_ignoreList":[0]}