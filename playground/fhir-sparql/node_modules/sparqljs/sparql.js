import { S as SparqlParser_1 } from './lib/SparqlParser.js';
import { S as SparqlGenerator } from './lib/SparqlGenerator.js';
import './lib/Wildcard.js';
import '../rdf-data-factory/index.js';
import { __exports as Wildcard$1 } from '../../_virtual/Wildcard.js';
import { __exports as rdfDataFactory } from '../../_virtual/index.js';

var Parser = SparqlParser_1.Parser;
var Generator = SparqlGenerator;
var Wildcard = Wildcard$1.Wildcard;
var { DataFactory } = rdfDataFactory;

var sparql = {
  /**
   * Creates a SPARQL parser with the given pre-defined prefixes and base IRI
   * @param options {
   *   prefixes?: { [prefix: string]: string },
   *   baseIRI?: string,
   *   factory?: import('rdf-js').DataFactory,
   *   sparqlStar?: boolean,
   *   skipValidation?: boolean,
   *   skipUngroupedVariableCheck?: boolean
   * }
   */
  Parser: function ({ prefixes, baseIRI, factory, sparqlStar, skipValidation, skipUngroupedVariableCheck, pathOnly } = {}) {

    // Create a copy of the prefixes
    var prefixesCopy = {};
    for (var prefix in prefixes || {})
      prefixesCopy[prefix] = prefixes[prefix];

    // Create a new parser with the given prefixes
    // (Workaround for https://github.com/zaach/jison/issues/241)
    var parser = new Parser();
    parser.parse = function () {
      Parser.base = baseIRI || '';
      Parser.prefixes = Object.create(prefixesCopy);
      Parser.factory = factory || new DataFactory();
      Parser.sparqlStar = Boolean(sparqlStar);
      Parser.pathOnly = Boolean(pathOnly);
      // We keep skipUngroupedVariableCheck for compatibility reasons.
      Parser.skipValidation = Boolean(skipValidation) || Boolean(skipUngroupedVariableCheck);
      return Parser.prototype.parse.apply(parser, arguments);
    };
    parser._resetBlanks = Parser._resetBlanks;
    return parser;
  },
  Generator: Generator,
  Wildcard: Wildcard,
};

export { sparql as s };
//# sourceMappingURL=sparql.js.map
